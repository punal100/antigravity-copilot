import * as vscode from 'vscode';
import * as path from 'path';
import * as os from 'os';
import * as fs from 'fs';
import * as net from 'net';
import { spawn, ChildProcess } from 'child_process';

export interface ServerConfig {
    enabled: boolean;
    autoStart: boolean;
    executablePath: string;
    port: number;
    host: string;
}

export interface ServerStatus {
    running: boolean;
    config: ServerConfig;
    pid?: number;
}

export class AntigravityServer implements vscode.Disposable {
    private process: ChildProcess | undefined;
    private config: ServerConfig;
    private disposed = false;

    private readonly _onDidChangeStatus = new vscode.EventEmitter<void>();
    public readonly onDidChangeStatus = this._onDidChangeStatus.event;

    constructor(
        private readonly output: vscode.OutputChannel,
        private readonly context: vscode.ExtensionContext
    ) {
        this.config = this.getServerConfig();

        // Listen for config changes
        vscode.workspace.onDidChangeConfiguration((e: vscode.ConfigurationChangeEvent) => {
            if (e.affectsConfiguration('antigravityCopilot')) {
                const newConfig = this.getServerConfig();
                const needsRestart = this.process && (
                    newConfig.port !== this.config.port ||
                    newConfig.host !== this.config.host ||
                    newConfig.executablePath !== this.config.executablePath
                );
                this.config = newConfig;
                if (needsRestart) {
                    void this.restart();
                }
            }
        });
    }

    private getServerConfig(): ServerConfig {
        const config = vscode.workspace.getConfiguration('antigravityCopilot.server');
        return {
            enabled: config.get<boolean>('enabled', false),
            autoStart: config.get<boolean>('autoStart', false),
            executablePath: config.get<string>('executablePath', '') || this.getDefaultExecutablePath(),
            port: config.get<number>('port', 8317),
            host: config.get<string>('host', '127.0.0.1')
        };
    }

    private getDefaultExecutablePath(): string {
        const userProfile = os.homedir();
        const defaultPath = path.join(userProfile, 'CLIProxyAPI', 'cli-proxy-api.exe');
        return defaultPath;
    }

    private getConfigPath(): string {
        return path.join(path.dirname(this.config.executablePath), 'config.yaml');
    }

    private ensureConfigExists(): void {
        const configPath = this.getConfigPath();
        
        if (fs.existsSync(configPath)) {
            this.logInfo(`Config file found at: ${configPath}`);
            return;
        }

        this.logInfo(`Creating default config file at: ${configPath}`);

        const userProfile = os.homedir();
        const authDir = path.join(userProfile, '.cli-proxy-api').replace(/\\/g, '\\\\');

        const defaultConfig = `# CLIProxyAPI Configuration
# Auto-generated by Antigravity for Copilot extension

port: ${this.config.port}
host: "${this.config.host}"

# Auth directory for storing credentials
auth-dir: "${authDir}"

# Enable Antigravity provider (Claude & Gemini via Google OAuth)
providers:
  antigravity:
    enabled: true
`;

        try {
            fs.writeFileSync(configPath, defaultConfig, 'utf8');
            this.logInfo('Default config file created successfully');
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            this.logError('Failed to create config file', error);
            throw new Error(`Failed to create config file: ${message}`);
        }
    }

    public getStatus(): ServerStatus {
        return {
            running: !!this.process,
            config: this.config,
            pid: this.process?.pid
        };
    }

    private logInfo(message: string) {
        this.output.appendLine(`[${new Date().toISOString()}] INFO ${message}`);
    }

    private logError(message: string, error?: unknown) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        this.output.appendLine(`[${new Date().toISOString()}] ERROR ${message}: ${errorMsg}`);
    }

    public async start(): Promise<void> {
        if (this.disposed) {
            return;
        }

        if (this.process) {
            this.logInfo('Server is already running');
            return;
        }

        // Check if executable exists
        if (!fs.existsSync(this.config.executablePath)) {
            const selection = await vscode.window.showErrorMessage(
                `CLIProxyAPI executable not found at: ${this.config.executablePath}`,
                'Download CLIProxyAPI',
                'Configure Path'
            );

            if (selection === 'Download CLIProxyAPI') {
                vscode.env.openExternal(vscode.Uri.parse('https://github.com/router-for-me/CLIProxyAPI/releases/latest'));
            } else if (selection === 'Configure Path') {
                vscode.commands.executeCommand('workbench.action.openSettings', 'antigravityCopilot.server.executablePath');
            }
            return;
        }

        // Ensure config.yaml exists
        this.ensureConfigExists();

        this.logInfo(`Starting CLIProxyAPI from: ${this.config.executablePath}`);

        // Spawn the process
        this.process = spawn(this.config.executablePath, [], {
            cwd: path.dirname(this.config.executablePath),
            stdio: ['ignore', 'pipe', 'pipe'],
            windowsHide: true
        });

        // Handle stdout
        this.process.stdout?.on('data', (data: Buffer) => {
            const lines = data.toString().trim().split('\n');
            for (const line of lines) {
                this.output.appendLine(`[SERVER] ${line}`);
            }
        });

        // Handle stderr
        this.process.stderr?.on('data', (data: Buffer) => {
            const lines = data.toString().trim().split('\n');
            for (const line of lines) {
                this.output.appendLine(`[SERVER ERROR] ${line}`);
            }
        });

        // Handle process exit
        this.process.on('exit', (code: number | null, signal: string | null) => {
            this.logInfo(`Server process exited with code ${code}, signal ${signal}`);
            this.process = undefined;
            this._onDidChangeStatus.fire();
        });

        // Handle process error
        this.process.on('error', (error: Error) => {
            this.logError('Failed to start server process', error);
            this.process = undefined;
            this._onDidChangeStatus.fire();
        });

        // Wait for the server to be ready by checking if the port is open
        const startTime = Date.now();
        const timeout = 10000; // 10 seconds timeout
        let serverReady = false;
        let lastError: Error | undefined;

        while (Date.now() - startTime < timeout) {
            // Check if process has exited
            if (!this.process || this.process.exitCode !== null) {
                throw new Error('Server process exited unexpectedly during startup');
            }

            // Try to connect to the server port
            try {
                await this.checkPortOpen(this.config.host, this.config.port);
                serverReady = true;
                break;
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                // Wait a bit before retrying
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        if (!serverReady) {
            // Server didn't become ready in time
            if (this.process) {
                this.process.kill('SIGTERM');
                this.process = undefined;
            }
            throw new Error(`Server failed to start: port ${this.config.port} is not responding after ${timeout / 1000}s`);
        }

        this.logInfo(`CLIProxyAPI started successfully (PID: ${this.process.pid}, Port: ${this.config.port})`);
        await this.updateServerConfig({ enabled: true });
        this._onDidChangeStatus.fire();
    }

    private checkPortOpen(host: string, port: number): Promise<void> {
        return new Promise((resolve, reject) => {
            const socket = new net.Socket();
            const timeout = 1000;

            socket.setTimeout(timeout);

            socket.on('connect', () => {
                socket.destroy();
                resolve();
            });

            socket.on('timeout', () => {
                socket.destroy();
                reject(new Error('Connection timeout'));
            });

            socket.on('error', (error: Error) => {
                socket.destroy();
                reject(error);
            });

            socket.connect(port, host);
        });
    }

    public async stop(): Promise<void> {
        if (!this.process) {
            this.logInfo('Server is not running');
            return;
        }

        this.logInfo('Stopping CLIProxyAPI...');

        const process = this.process;
        this.process = undefined;

        // Kill the process
        if (process.pid) {
            try {
                process.kill('SIGTERM');
                
                // Wait for process to exit gracefully
                await new Promise<void>((resolve) => {
                    const timeout = setTimeout(() => {
                        // Force kill if not exited
                        if (process.exitCode === null) {
                            process.kill('SIGKILL');
                        }
                        resolve();
                    }, 5000);

                    process.once('exit', () => {
                        clearTimeout(timeout);
                        resolve();
                    });
                });
            } catch (error) {
                this.logError('Error stopping server', error);
            }
        }

        this.logInfo('CLIProxyAPI stopped');
        await this.updateServerConfig({ enabled: false });
        this._onDidChangeStatus.fire();
    }

    public async restart(): Promise<void> {
        if (this.disposed) {
            return;
        }
        this.logInfo('Restarting CLIProxyAPI...');
        await this.stop();
        await new Promise(resolve => setTimeout(resolve, 1000));
        await this.start();
    }

    public async login(): Promise<void> {
        // Check if executable exists
        if (!fs.existsSync(this.config.executablePath)) {
            const selection = await vscode.window.showErrorMessage(
                `CLIProxyAPI executable not found at: ${this.config.executablePath}`,
                'Download CLIProxyAPI',
                'Configure Path'
            );

            if (selection === 'Download CLIProxyAPI') {
                vscode.env.openExternal(vscode.Uri.parse('https://github.com/router-for-me/CLIProxyAPI/releases/latest'));
            } else if (selection === 'Configure Path') {
                vscode.commands.executeCommand('workbench.action.openSettings', 'antigravityCopilot.server.executablePath');
            }
            return;
        }

        // Ensure config.yaml exists before login
        this.ensureConfigExists();

        // Stop server if running to avoid file locks
        if (this.process) {
            const selection = await vscode.window.showWarningMessage(
                'The Antigravity server must be stopped to perform login. Stop server now?',
                'Yes', 'No'
            );
            
            if (selection !== 'Yes') {
                return;
            }
            
            await this.stop();
        }

        const terminal = vscode.window.createTerminal({
            name: 'Antigravity Login',
            cwd: path.dirname(this.config.executablePath),
            hideFromUser: false
        });

        terminal.show();
        // Use & call operator for PowerShell to execute quoted paths
        terminal.sendText(`& "${this.config.executablePath}" --antigravity-login`);

        vscode.window.showInformationMessage(
            'Follow the instructions in the terminal to login to Antigravity',
            'OK'
        );
    }

    private async updateServerConfig(updates: Partial<ServerConfig>): Promise<void> {
        const config = vscode.workspace.getConfiguration('antigravityCopilot');
        for (const [key, value] of Object.entries(updates)) {
            await config.update(`server.${key}`, value, vscode.ConfigurationTarget.Global);
        }
    }

    public async dispose(): Promise<void> {
        this.disposed = true;
        await this.stop();
        this._onDidChangeStatus.dispose();
    }
}
